using System;
using System.Collections.Generic;
using System.Linq;
using System.Text;
using System.Threading.Tasks;

namespace Test1
{
    class Search
    {
		/*бинарный поиск, только для отсортированных массивов, element наш волшебный элемент
		 * также возможно все это реализовать в рекурсивном виде, но он по идеи будет работать медленнее 
		 * */
		public static int BinarySearch(int[] array, int element)
		{
			if (array.Length>0)
            {
				var left = 0;
				var right = array.Length - 1;
				while (left < right)
				{
					var middle = (right + left) / 2; 
					if (element <= array[middle]) 
						right = middle; 
					else left = middle + 1; 
				}
				if (array[right] == element) 
					return right; // товернуть индекс элемента 
			}
			
			return -1; //если элемент не найден то вернуть -1
		}

		//добавить рекурсию
		//добавить обобщенный метод с компаратором
	}
}


using System;
using System.Collections.Generic;
using System.Linq;
using System.Text;
using System.Threading.Tasks;
using NUnit.Framework;

namespace Test1
{
    [TestFixture]
    class SearchTest
    {
        [TestCase(new[] { 1, 2, 3, 4, 5 }, 0, -1)]
        [TestCase(new[] { 1, 2, 3, 4, 5 }, 1, 0)]
        [TestCase(new[] { 1, 2, 3, 4, 5 }, 5, 4)]
        [TestCase(new[] { 1, 2, 3, 4, 5 }, 3, 2)]
        [TestCase(new[] { 1, 2, 3, 4, 5 }, 6, -1)]
        [TestCase(new[] { 1, 2, 4, 5 }, 3, -1)]
        [TestCase(new int[0], 3, -1)]

        public static void RunTests(int[] input, int searchElement, int expectedOutput)
        {
            Test(input, searchElement, expectedOutput);
        }

        public static void Test(int[] input, int searchElement, int expectedResult)
        {
            var actualResult = Search.BinarySearch(input, searchElement);
            Assert.AreEqual(expectedResult, actualResult);
        }
    }
}

